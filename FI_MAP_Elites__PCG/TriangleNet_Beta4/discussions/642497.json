[
  {
    "Id": "1437866",
    "ThreadId": "642497",
    "Html": "Hello,\r<br />\n<br />\nI've been working on a project using unity and triangle, and I'm having weird issues with the refinement procedure. I'm using the Beta 3 download. The issues are best illustrated with images:<br />\n<ul>\n<li>\nthis is what happens when I just triangulate, without refining (or setting the behavior settings so that there is no difference: minAngle 0, maxAngle 180, MaxArea = statistic.LargestArea * 1:\r<br />\n<a href=\"https://drive.google.com/file/d/0B9Sm8zke1RqAZU5CSjlJa2JlbE0/view?usp=sharing\" rel=\"nofollow\">https://drive.google.com/file/d/0B9Sm8zke1RqAZU5CSjlJa2JlbE0/view?usp=sharing</a>\r<br />\n-this is what happens when I set the behavior such that refinement will actually take place (in this case, minAngle = 20, MaxArea = statistic.LargestArea * 0.5.\r<br />\n<a href=\"https://drive.google.com/file/d/0B9Sm8zke1RqAdFd3NUd6LWU2RFE/view?usp=sharing\" rel=\"nofollow\">https://drive.google.com/file/d/0B9Sm8zke1RqAdFd3NUd6LWU2RFE/view?usp=sharing</a><br />\n</li>\n</ul>\nThe code I'm using is as follows:<br />\n<pre><code>var geometry = new InputGeometry();\n\n/*for loop on the points on my curves to create the points (AddPoint) and segments (AddSegment)  to the InputGeometry */\n\nTriangleNet.Mesh m = new TriangleNet.Mesh();\nm.Triangulate(geometry);\n\nvar statistic = new TriangleNet.Tools.Statistic();\n statistic.Update(m, 1);\nm.Behavior.MinAngle = (double)minAngle;\nm.Behavior.MaxAngle = (double)maxAngle;\nm.Behavior.MaxArea = statistic.LargestArea * (double)maxAreaRatio;\n\nm.Refine();\n\n/* loop through m.Vertices to retrieve verts, and m.Triangles to retrieve triangles.\nConstruct unity mesh from these */\n</code></pre>\n\nI've tried a bunch of different things to no avail (playing with parameter values, adding m.Behaviour.Quality = true, copying code from the demo app). The demo app does seem to work perfectly fine though, and I copied the triangle source code directly from that. Any ideas?\r<br />\n<br />\nThanks!<br />\n",
    "PostedDate": "2015-08-08T19:28:55.423-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1437883",
    "ThreadId": "642497",
    "Html": "This looks a lot like you're messing up the triangle indices, so please review this part:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">/* loop through m.Vertices to retrieve verts, and m.Triangles to retrieve triangles.\nConstruct unity mesh from these */</span>\r\n</pre></div>Additionally, you can check for any error's in the mesh by doing:<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">bool</span> isConsistent, isDelauany;\nm.Check(<span style=\"color:Blue;\">out</span> isConsistent, <span style=\"color:Blue;\">out</span> isDelauany);\n\n<span style=\"color:Blue;\">foreach</span> (<span style=\"color:Blue;\">var</span> msg <span style=\"color:Blue;\">in</span> TriangleNet.Log.SimpleLog.Instance.Data)\n{\n    Console.WriteLine(msg.Message);\n}\r\n</pre></div>EDIT: before passing data to another application, you should always call <code>m.Renumber();</code> to ensure vertices are numbered linearly. But I'm not sure it will make difference in this case.<br />\n",
    "PostedDate": "2015-08-09T02:46:57.96-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1437895",
    "ThreadId": "642497",
    "Html": "m.Renumber actually solved this issue completely! Thanks!\r<br />\n<br />\nThere is another issue that happens while refining (and has happened in the past occasionally as well). This relates specifically to the interpolation of attributes on vertecies. In this case, I'm using an attribute for the z-value, And I will sometimes get these kinds of errors:\r<br />\n<br />\n<a href=\"https://drive.google.com/file/d/0B9Sm8zke1RqAWVgyMUNEUno0QnM/view?usp=sharing\" rel=\"nofollow\">https://drive.google.com/file/d/0B9Sm8zke1RqAWVgyMUNEUno0QnM/view?usp=sharing</a>\r<br />\n<a href=\"https://drive.google.com/file/d/0B9Sm8zke1RqAUTByMWl0WE82R2c/view?usp=sharing\" rel=\"nofollow\">https://drive.google.com/file/d/0B9Sm8zke1RqAUTByMWl0WE82R2c/view?usp=sharing</a>\r<br />\n<a href=\"https://drive.google.com/file/d/0B9Sm8zke1RqANWwtYzFtcFRIZzQ/view?usp=sharing\" rel=\"nofollow\">https://drive.google.com/file/d/0B9Sm8zke1RqANWwtYzFtcFRIZzQ/view?usp=sharing</a>\r<br />\n<br />\nIt seems to create seemingly random bumps, spikes, and other artifacts in the non-boundary regions, and they change drastically with the slightest movement of a vertex. In the images, the set vertecies are where the transform handles are, and the only difference between the images is that I moved one vertex.\r<br />\n<br />\nDo you have a clue as to why this is, or what one can do to improve it?\r<br />\n<br />\nThanks!<br />\n",
    "PostedDate": "2015-08-09T05:55:46.853-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1437909",
    "ThreadId": "642497",
    "Html": "No, I never had this kind of issue. Do you have a static example (pure C#, no Unity stuff), where this issue occurs?<br />\n",
    "PostedDate": "2015-08-09T09:10:09.19-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1437911",
    "ThreadId": "642497",
    "Html": "Of course - I managed to reproduce it by re-making the shape I used in unity as a poly file and using the sample mesh explorer project. I added a text box to the statistics panel that writes out a list of the vertecies and their attributes, and found that I still got these issues when refining (There were attributes that had values that were larger in absolute value than any of the values I provided).<br />\nThe full solution with that minor change is here: <a href=\"https://drive.google.com/file/d/0B9Sm8zke1RqAQmpxa1dseGd5S1U/view?usp=sharing\" rel=\"nofollow\">https://drive.google.com/file/d/0B9Sm8zke1RqAQmpxa1dseGd5S1U/view?usp=sharing</a><br />\njust load the test.poly file in the data folder when running the mesh explorer, triangulate using a min angle of 25, a max angle of 95 and a max area of 0.2, and look at the text in the vertex list text box in the statistics panel.<br />\n(The only change to code I made was adding that box, and populating it in the HandleMeshChange method of the StatisticView).<br />\n<br />\nHere is the poly data I used:<br />\n<pre><code>9 2 1 1\n1 -564.963 -961.3954 0 1\n2 766.894 -643.5915 0 1\n3 650.1689 379.2653 0 1\n4 -251.2134 365.9495 0 1\n5 -1552.631 -71.71667 0 1\n6 -256.2429 -499.8359 291.8905 1\n7 611.605 -445.8072 270.9263 1\n8 433.6885 237.7357 0 1\n9 -224.3082 296.6656 -147.7938 1\n9 1\n1 1 2 1\n2 2 3 1\n3 3 4 1\n4 4 5 1\n5 5 1 1\n6 6 7 1\n7 7 8 1\n8 8 9 1\n9 9 1 1\n0</code></pre>\n\nAnd here is my vertex list without refinement:<br />\n<pre><code>0: x - -564.963 y - -961.3954 attributes: 0 \n1: x - 766.894 y - -643.5915 attributes: 0 \n2: x - 650.1689 y - 379.2653 attributes: 0 \n3: x - -251.2134 y - 365.9495 attributes: 0 \n4: x - -1552.631 y - -71.71667 attributes: 0 \n5: x - -256.2429 y - -499.8359 attributes: 291.8905 \n6: x - 611.605 y - -445.8072 attributes: 270.9263 \n7: x - 433.6885 y - 237.7357 attributes: 0 \n8: x - -224.3082 y - 296.6656 attributes: -147.7938 </code></pre>\n\nAnd with refinement:<br />\n<pre><code>0: x - -564.963 y - -961.3954 attributes: 0 \n1: x - 766.894 y - -643.5915 attributes: 0 \n2: x - 650.1689 y - 379.2653 attributes: 0 \n3: x - -251.2134 y - 365.9495 attributes: 0 \n4: x - -1552.631 y - -71.71667 attributes: 0 \n5: x - -256.2429 y - -499.8359 attributes: 291.8905 \n6: x - 611.605 y - -445.8072 attributes: 270.9263 \n7: x - 433.6885 y - 237.7357 attributes: 0 \n8: x - -224.3082 y - 296.6656 attributes: -147.7938 \n9: x - 708.53145 y - -132.1631 attributes: 0 \n10: x - 199.47775 y - 372.6074 attributes: 0 \n11: x - -431.143915299624 y - -467.192554429526 attributes: -58.0576907778506 \n12: x - 104.69015 y - 267.20065 attributes: -73.8969 \n13: x - -901.9222 y - 147.116415 attributes: 0 \n14: x - -25.867825 y - 369.27845 attributes: 0 \n15: x - -576.5678 y - 256.5329575 attributes: 0 \n16: x - -138.5406125 y - 367.613975 attributes: 0 \n17: x - -413.8906 y - 311.24122875 attributes: 0 \n18: x - -327.726057649812 y - -85.2634772147631 attributes: -102.925745388925 \n19: x - -59.809025 y - 281.933125 attributes: -110.84535 \n20: x - -347.379855881782 y - 250.377981232561 attributes: -175.814476027355 \n21: x - -291.217742350189 y - 49.5641772147634 attributes: -118.764954611075 \n22: x - -418.084278055385 y - 190.071277952843 attributes: -346.003650801662 \n23: x - 306.198771047277 y - 249.153625011191 attributes: -28.6356930101518 \n24: x - 424.823325 y - 375.93635 attributes: 0 \n25: x - 522.64675 y - -104.03575 attributes: 135.46315 \n26: x - -515.466784531917 y - -51.6489960405488 attributes: -315.887448969853 \n27: x - 177.68105 y - -472.82155 attributes: 281.4084 \n28: x - 100.9655 y - -802.49345 attributes: 0 \n29: x - -41.5848691806783 y - -158.266710236183 attributes: -40.9905231773482 \n30: x - -133.098533259951 y - 122.50277004416 attributes: -103.198189729375 \n31: x - -231.99875 y - -881.944425 attributes: 0 \n32: x - 90.2317996209904 y - 105.988124338587 attributes: -58.1495187953537 \n33: x - -498.053457649812 y - -714.293977214763 attributes: -29.0288453889253 \n34: x - 737.712725 y - -387.8773 attributes: 0 \n35: x - 310.17797471778 y - 8.67373936416598 attributes: 55.3305754749748 \n36: x - 567.125875 y - -274.921475 attributes: 203.194725 \n37: x - -379.434986474718 y - -276.228015822145 attributes: -80.4917180833879 \n38: x - 394.643025 y - -459.314375 attributes: 276.16735 \n39: x - 679.350175 y - 123.5511 attributes: 0 \n40: x - 433.92975 y - -723.042475 attributes: 0 \n41: x - -945.380654542575 y - -618.720031593798 attributes: 0 \n42: x - -781.62194738104 y - -238.8341525917 attributes: -515.414188776497 \n43: x - 318.978131932777 y - -231.354374135286 attributes: 185.80570589094 \n44: x - -755.171827271288 y - -790.057715796899 attributes: 0 \n45: x - -685.200492947001 y - -553.347054809233 attributes: -292.929303370824 </code></pre>\n\nDo you have any clue what could be causing this, or where I should look if I want to fix this?<br />\n<br />\nThanks again!<br />\n<br />\nEDIT: added triangulation details<br />\n<br />\nEDIT 2: It seems that the problem lies in the Quality.cs file, specifically in the SplitTriangle method. It has the following code:<br />\n<pre><code>for (int i = 0; i &lt; mesh.nextras; i++)\n                    {\n                        // Interpolate the vertex attributes at the circumcenter.\n                        newvertex.attributes[i] = borg.attributes[i]\n                           + xi * (bdest.attributes[i] - borg.attributes[i])\n                            + eta * (bapex.attributes[i] - borg.attributes[i]);\n                    }</code></pre>\n\nxi &amp; eta are part of the Barycentric coordinates for the triangles, but there is one problem: they can sometimes be outside the triangle. Occasionally, they are more than 1 or less than 0. And on those occasions, the values inside the triangle will be scaled in a manner that doesn't match the actual values. Not yet sure how to solve this though. I still don't know where to find the actual coordinates of the point relative to it's containing triangle. But now I know it occurs when you have triangles that do not contain their circumcenters.<br />\n",
    "PostedDate": "2015-08-09T10:13:18.18-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1437927",
    "ThreadId": "642497",
    "Html": "Yes , I can confirm this. A possible fix/workaround might be to only use offcenters (the original Triangle code) for Steiner point locations. So, in Quality.cs find<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">if</span> (behavior.fixedArea || behavior.VarArea)\n{\n    newloc = Primitives.FindCircumcenter(borg, bdest, bapex, <span style=\"color:Blue;\">ref</span> xi, <span style=\"color:Blue;\">ref</span> eta, behavior.offconstant);\n}\n<span style=\"color:Blue;\">else</span>\n{\n    newloc = newLocation.FindLocation(borg, bdest, bapex, <span style=\"color:Blue;\">ref</span> xi, <span style=\"color:Blue;\">ref</span> eta, <span style=\"color:Blue;\">true</span>, badotri);\n}\r\n</pre></div>and always use <code>Primitives.FindCircumcenter</code>.<br />\n",
    "PostedDate": "2015-08-09T15:30:21.037-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1437934",
    "ThreadId": "642497",
    "Html": "The fix that ended up working for me is this:<br />\n1) In the Mesh class, add an optional boolean calcAttr parameter to the InsertVertex method:<br />\n<pre><code>internal InsertVertexResult InsertVertex(Vertex newvertex, ref Otri searchtri,\n            ref Osub splitseg, bool segmentflaws, bool triflaws, bool calcAttr = false)</code></pre>\n\nThis tells me that the InsertVertex method should calculate the attributes, rather than them being supplied by the newvertex.<br />\n2) Then change this:<br />\n<pre><code> else\n            {\n                // Insert the vertex in a triangle, splitting it into three.\n                horiz.Lnext(ref botleft);\n                horiz.Lprev(ref botright);\n                botleft.Sym(ref botlcasing);\n                botright.Sym(ref botrcasing);\n                MakeTriangle(ref newbotleft);\n                MakeTriangle(ref newbotright);\n\n                // Set the vertices of changed and new triangles.\n                rightvertex = horiz.Org();\n                leftvertex = horiz.Dest();\n                botvertex = horiz.Apex();\n                newbotleft.SetOrg(leftvertex);\n                newbotleft.SetDest(botvertex);\n                newbotleft.SetApex(newvertex);\n                newbotright.SetOrg(botvertex);\n                newbotright.SetDest(rightvertex);\n                newbotright.SetApex(newvertex);\n                horiz.SetApex(newvertex);</code></pre>\n\nto this:<br />\n<pre><code> else\n            {\n                // Insert the vertex in a triangle, splitting it into three.\n                horiz.Lnext(ref botleft);\n                horiz.Lprev(ref botright);\n                botleft.Sym(ref botlcasing);\n                botright.Sym(ref botrcasing);\n                MakeTriangle(ref newbotleft);\n                MakeTriangle(ref newbotright);\n\n                // Set the vertices of changed and new triangles.\n                rightvertex = horiz.Org();\n                leftvertex = horiz.Dest();\n                botvertex = horiz.Apex();\n\n                if(calcAttr)\n                {\n                    double xdo, ydo, xao, yao;\n                    double denominator;\n                    double dodist, aodist;\n                    double dx, dy;\n                    xdo = leftvertex.x - rightvertex.x;\n                    ydo = leftvertex.y - rightvertex.y;\n                    xao = botvertex.x - rightvertex.x;\n                    yao = botvertex.y - rightvertex.y;\n                    denominator = 0.5 / (xdo * yao - xao * ydo);\n                    dodist = xdo * xdo + ydo * ydo;\n                    aodist = xao * xao + yao * yao;\n                    dx = newvertex.x - rightvertex.x; //Note that this is different than the regular calculations used for dx/dy.\n                    dy = newvertex.y - rightvertex.y;\n                    double xi = (yao * dx - xao * dy) * (2.0 * denominator);\n                    double eta = (xdo * dy - ydo * dx) * (2.0 * denominator);\n                    for (int i = 0; i &lt; nextras; i++)\n                    {\n                        // Interpolate the vertex attributes at the circumcenter.\n                        newvertex.attributes[i] = rightvertex.attributes[i]\n                           + xi * (leftvertex.attributes[i] - rightvertex.attributes[i])\n                            + eta * (botvertex.attributes[i] - rightvertex.attributes[i]);\n                    }\n                }\n\n                newbotleft.SetOrg(leftvertex);\n                newbotleft.SetDest(botvertex);\n                newbotleft.SetApex(newvertex);\n                newbotright.SetOrg(botvertex);\n                newbotright.SetDest(rightvertex);\n                newbotright.SetApex(newvertex);\n                horiz.SetApex(newvertex);</code></pre>\n\nHere I'm checking if the calcAttr bool is set, and if so I'm doing the attribute calculation using the corners of the triangle actually being split by the new vertex.<br />\n<br />\nFinally, in Quality.cs, in the SplitTriangle method, I commented out the calculation of the newvertex attributes, and added a true at the end of the function call to InsertVertex that comes immediately after.<br />\n<br />\nThanks again, and I hope this helps.<br />\n",
    "PostedDate": "2015-08-09T18:20:13.033-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1438037",
    "ThreadId": "642497",
    "Html": "This discussion has been copied to a work item. Click <a href=\"https://triangle.codeplex.com/workitem/10971\" rel=\"nofollow\">here</a> to go to the work item and continue the discussion.<br />\n",
    "PostedDate": "2015-08-10T11:50:49.387-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1446111",
    "ThreadId": "642497",
    "Html": "Can you confirm that the latest changeset fixes the issue?<br />\n",
    "PostedDate": "2015-09-27T13:23:05.877-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]